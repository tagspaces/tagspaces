/**
 * TagSpaces - universal file and folder organizer
 * Copyright (C) 2024-present TagSpaces GmbH
 *
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Affero General Public License (version 3) as
 * published by the Free Software Foundation.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Affero General Public License for more details.
 *
 * You should have received a copy of the GNU Affero General Public License
 * along with this program.  If not, see <https://www.gnu.org/licenses/>.
 *
 */

import AutoAwesomeOutlinedIcon from '@mui/icons-material/AutoAwesomeOutlined';
import { CircularProgress } from '@mui/material';
import React, { useState } from 'react';
import { useTranslation } from 'react-i18next';
import { TsIconButton } from '-/components/misc/TsIconButton';
import { useChatContext } from '-/hooks/ChatProvider';
import { useNotificationContext } from '-/hooks/useNotificationContext';
import { TS } from '-/tagspaces.namespace';

export const AiGenTagsButton = ({
  generateEntries,
  fromDescription,
  generationCompleted,
}: {
  generateEntries: TS.FileSystemEntry[];
  fromDescription?: boolean;
  generationCompleted?: () => void;
}) => {
  const { t } = useTranslation();
  const { showNotification } = useNotificationContext();
  const { tagsGenerate, checkActiveProviderModels } = useChatContext(); // Updated
  const [isLoading, setIsLoading] = useState(false);

  const handleGeneration = () => {
    setIsLoading(true);
    checkActiveProviderModels() // Updated
      .then((success) => {
        if (success) {
          const promises = generateEntries.map((entry) => {
            return tagsGenerate(entry, fromDescription)
              .then(() => {
                if (generationCompleted) {
                  generationCompleted();
                }
                return true; // Indicate success for this entry
              })
              .catch((err) => {
                console.error('Error generating tags for entry:', entry.name, err);
                return false; // Indicate failure
              });
          });
          Promise.all(promises)
            .then((results) => {
              if (results && results.every((result) => result)) {
                showNotification('Tags generated by an AI.');
              } else if (results && results.some((r) => r)) {
                showNotification('Tags generated for some entries.');
              } else if (results && !results.some((r) => r) && results.length > 0) {
                 showNotification(t('core:aiFailedToGenerateTagsForAll', 'Failed to generate tags for any entry.'));
              }
            })
            .catch((err) => {
                console.error('Error in Promise.all for tagsGenerate:', err);
                showNotification(t('core:aiTagGenerationError', 'An error occurred during tag generation.'));
            })
            .finally(() => {
                setIsLoading(false);
            });
        } else {
          showNotification(
            t('core:aiProviderNotReady', 
              'AI Provider not ready or models not loaded. Check your AI provider settings and connection.',
            ),
          );
          setIsLoading(false); 
        }
      })
      .catch(() => {
        showNotification(t('core:aiProviderCheckFailed', 'Failed to check AI provider status.'));
        setIsLoading(false);
      });
  };

  return (
    <TsIconButton
      data-tid="generateTagsWithAI"
      size="small"
      onClick={handleGeneration}
      disabled={isLoading}
    >
      {isLoading ? (
        <CircularProgress size={20} />
      ) : (
        <AutoAwesomeOutlinedIcon fontSize="small" />
      )}
    </TsIconButton>
  );
};
